<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tadpole Trials - 1st Rank Biology</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: manipulation;
    }
    
    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      overflow-x: hidden;
    }
    
    header {
      text-align: center;
      margin-bottom: 10px;
      width: 100%;
      max-width: 800px;
      padding-top: 5px;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 5px;
      text-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
      position: relative;
      display: inline-block;
    }
    
    h1:after {
      content: "üê∏";
      position: absolute;
      right: -40px;
      top: -5px;
      font-size: 2rem;
      animation: jump 2s infinite;
    }
    
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
      background: rgba(0, 20, 40, 0.85);
      border-radius: 15px;
      padding: 15px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 100, 200, 0.5);
      border: 2px solid #00ccff;
      position: relative;
    }
    
    .screen {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 15px;
    }
    
    #startScreen {
      text-align: center;
    }
    
    #gameCanvas {
      background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
      border: 3px solid #00aaff;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
      max-width: 100%;
      width: 100%;
      height: auto;
      aspect-ratio: 2 / 1;
      box-sizing: border-box;
    }
    
    #quiz, #scoreScreen, #finalScreen {
      background: rgba(10, 30, 60, 0.9);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }
    
    #questionText {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #aaffff;
      line-height: 1.4;
    }
    
    .optionBtn {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      background: linear-gradient(to right, #1e3c72, #2a5298);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      position: relative;
      overflow: hidden;
    }
    
    .optionBtn:active {
      transform: translateY(1px);
    }
    
    .optionBtn:before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 5px;
      background: #00ccff;
    }
    
    button {
      background: linear-gradient(to right, #00c6ff, #0072ff);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1.1rem;
      border-radius: 40px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 8px;
      box-shadow: 0 4px 12px rgba(0, 100, 200, 0.4);
      font-weight: bold;
      min-width: 140px;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .stats {
      display: flex;
      justify-content: space-around;
      width: 100%;
      padding: 12px;
      background: rgba(0, 30, 60, 0.7);
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 1rem;
      border: 1px solid #00aaff;
      flex-wrap: wrap;
    }
    
    .stats span {
      color: #aaffff;
      font-weight: bold;
    }
    
    .instructions {
      background: rgba(0, 40, 80, 0.7);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      width: 100%;
      max-width: 600px;
      text-align: center;
      border: 1px solid #00ccff;
    }
    
    .instructions p {
      margin: 8px 0;
      line-height: 1.5;
    }
    
    .key {
      display: inline-block;
      background: rgba(0, 100, 200, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      margin: 0 4px;
      font-weight: bold;
      border: 1px solid #00aaff;
    }
    
    .brain-counter {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 1.1rem;
      margin: 8px 0;
    }
    
    .brain-icon {
      color: #ff66cc;
      font-size: 1.5rem;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    @keyframes jump {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    
    .level-indicator {
      font-size: 1.2rem;
      margin: 12px 0;
      padding: 8px 16px;
      background: rgba(0, 100, 200, 0.3);
      border-radius: 40px;
      display: inline-block;
      border: 1px solid #00ccff;
    }
    
    .correct {
      background: linear-gradient(to right, #00b09b, #96c93d) !important;
    }
    
    .incorrect {
      background: linear-gradient(to right, #ff416c, #ff4b2b) !important;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 15px;
    }
    
    .death-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(200, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    .death-message {
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      font-size: 1.2rem;
    }
    
   /* Mobile Controls */
#mobileControls {
  display: none;
  position: absolute;
  bottom: 20px;
  width: calc(100% - 30px);
  justify-content: space-between;
  z-index: 5;
  pointer-events: none;
}

#mobileControls,
#mobileControls button {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

/* Visibility control */
@media (max-width: 768px) {
  .game-container.game-active #mobileControls {
    display: flex;
  }
}
    
    .dpad-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    
    .dpad-row {
      display: flex;
      gap: 5px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
    }
    
    .jump-btn {
      width: 70px;
      height: 70px;
      background: rgba(0, 100, 200, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      touch-action: manipulation;
      user-select: none;
      align-self: flex-end;
      margin-right: 10px;
    }
    
    /* New shoot button */
    .shoot-btn {
      width: 70px;
      height: 70px;
      background: rgba(200, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 14px;
      font-weight: bold;
      color: white;
      pointer-events: auto;
      align-self: flex-end;
      margin-right: 10px;
      position: absolute;
      right: 10px;
      bottom: 90px;
    }
    
    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      h1:after {
        right: -35px;
        font-size: 1.8rem;
      }
      
      .game-container {
        padding: 10px;
        border-radius: 12px;
      }
      
      .screen {
        padding: 10px;
      }
      
      #quiz, #scoreScreen, #finalScreen {
        padding: 15px;
      }
      
      #questionText {
        font-size: 1.1rem;
      }
      
      .optionBtn {
        padding: 10px;
        font-size: 0.95rem;
      }
      
      button {
        padding: 10px 20px;
        font-size: 1rem;
        min-width: 120px;
      }
      
      .stats {
        flex-direction: column;
        gap: 8px;
      }
      
      .controls {
        flex-direction: column;
        gap: 10px;
      }
      
      #mobileControls {
        display: flex;
      }
      
      /* Hide up arrow on mobile */
      #upBtn {
        display: none !important;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 1.8rem;
      }
      
      h1:after {
        right: -30px;
        font-size: 1.5rem;
      }
      
      .level-indicator {
        font-size: 1rem;
        padding: 6px 12px;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      .jump-btn {
        width: 60px;
        height: 60px;
        font-size: 14px;
      }
      
      .shoot-btn {
        width: 60px;
        height: 60px;
        font-size: 12px;
        bottom: 80px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Tadpole Trials</h1>
    <p class="level-indicator">Journey through the world of biology!</p>
  </header>
  
  <div class="game-container">
    <!-- Mobile Controls -->
    <div id="mobileControls">
      <div class="dpad-container">
        <div class="dpad-row">
          <div class="control-btn" id="upBtn">‚Üë</div>
        </div>
        <div class="dpad-row">
          <div class="control-btn" id="leftBtn">‚Üê</div>
          <div class="control-btn" id="downBtn" style="visibility: hidden;"></div>
          <div class="control-btn" id="rightBtn">‚Üí</div>
        </div>
      </div>
      <div class="jump-btn" id="jumpBtn">JUMP</div>
      <div class="shoot-btn" id="shootBtn">SHOOT</div>
    </div>
    
    <!-- Start Screen -->
    <div id="startScreen" class="screen">
      <div class="instructions">
        <h2>üê∏ Welcome to Tadpole Trials!</h2>
        <p>You're a brave tadpole exploring the fascinating world of biology!</p>
        <p>Collect <span class="brain-icon">üß†</span> brains to unlock quiz questions at the end of each level.</p>
        
        <div class="stats">
          <p>üéÆ <span>Controls:</span></p>
          <p>Move: <span class="key">‚Üê</span> <span class="key">‚Üí</span></p>
          <p>Jump: <span class="key">‚Üë</span> or <span class="key">Space</span></p>
          <p>Shoot: <span class="key">F</span> key or mobile button</p>
          <p>Defeat enemies: <span class="key">Jump</span> or shoot them</p>
        </div>
        
        <div class="stats">
          <p>‚≠ê <span>Levels:</span></p>
          <p>1-2: <span>Easy</span> (10 questions)</p>
          <p>2-3: <span>Medium</span> (10 questions)</p>
          <p>4-7: <span>Hard</span> (15 questions)</p>
        </div>
      </div>
      <button id="startBtn">Start Game</button>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="deathOverlay" class="death-overlay">
      <div class="death-message">Oh no! Press R to respawn</div>
    </div>
    
    <!-- Quiz Screen -->
    <div id="quiz" class="screen">
      <h2>üß† Biology Quiz</h2>
      <div class="brain-counter">
        <span class="brain-icon">üß†</span> 
        <span id="collectedCount">0</span> Collected
      </div>
      <h3 id="questionText"></h3>
      <div id="optionsContainer"></div>
    </div>
    
    <!-- Score Screen -->
    <div id="scoreScreen" class="screen">
      <h2>Level Complete! üéâ</h2>
      <h3 id="scoreSummary"></h3>
      <div class="controls">
        <button id="retryBtn">üîÅ Retry Level</button>
        <button id="nextBtn">‚û° Next Level</button>
      </div>
    </div>
    
    <!-- Final Screen -->
    <div id="finalScreen" class="screen">
      <h2>Congratulations! üèÜ</h2>
      <h3 id="finalText"></h3>
      <button id="restartBtn">Play Again</button>
    </div>
  </div>

  <script>
    // Mobile detection
    // More reliable mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Game state with enhanced physics and enemies
    const gameState = {
  currentLevel: 1,
  levels: [
    // First 2 levels - Easy
    { name: "Pond", questions: 10, collected: 0, brains: 5 },
    { name: "Stream", questions: 10, collected: 0, brains: 5 },
    
    // Next 2 levels - Medium
    { name: "Forest", questions: 10, collected: 0, brains: 5 },
    { name: "Caves", questions: 10, collected: 0, brains: 5 },
    
    // Final 3 levels - Hard
    { name: "Volcano", questions: 15, collected: 0, brains: 5 },
    { name: "City", questions: 15, collected: 0, brains: 5 },
    { name: "Ocean", questions: 15, collected: 0, brains: 5 }
  ],
      player: {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: -12,
        gravity: 0.5,
        friction: 0.8,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3
      },
      platforms: [],
      brains: [],
      enemies: [],
      playerProjectiles: [],
      enemyProjectiles: [],
      shootCooldown: 0,
      endFlag: null,
      collectedBrains: [],
      quizQuestions: [],
      usedQuestions: [], // Track all used questions across levels
      currentQuestion: 0,
      score: {
        correct: 0,
        total: 0
      },
      keys: {
        left: false,
        right: false,
        up: false,
        r: false,
        shoot: false
      },
      gameActive: false,
      cameraX: 0,
      levelWidth: 2000,
      isDead: false
    };

    // DOM elements
    const startScreen = document.getElementById('startScreen');
    const gameCanvas = document.getElementById('gameCanvas');
    const quizScreen = document.getElementById('quiz');
    const scoreScreen = document.getElementById('scoreScreen');
    const finalScreen = document.getElementById('finalScreen');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');
    const nextBtn = document.getElementById('nextBtn');
    const restartBtn = document.getElementById('restartBtn');
    const questionText = document.getElementById('questionText');
    const optionsContainer = document.getElementById('optionsContainer');
    const scoreSummary = document.getElementById('scoreSummary');
    const finalText = document.getElementById('finalText');
    const collectedCount = document.getElementById('collectedCount');
    const levelIndicator = document.querySelector('.level-indicator');
    const deathOverlay = document.getElementById('deathOverlay');
    const mobileControls = document.getElementById('mobileControls');
    const ctx = gameCanvas.getContext('2d');
    
    // Mobile control elements
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const upBtn = document.getElementById('upBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const shootBtn = document.getElementById('shootBtn');

// Function to show specific screen and hide others
function showScreen(screen) {
  // Hide all screens
  startScreen.style.display = 'none';
  gameCanvas.style.display = 'none';
  quizScreen.style.display = 'none';
  scoreScreen.style.display = 'none';
  finalScreen.style.display = 'none';
  
  // Show requested screen
  screen.style.display = 'flex';
  
  // Toggle game-active class on game container (replaces the mobileControls check)
  document.querySelector('.game-container').classList.toggle('game-active', screen === gameCanvas);
}

    // Initialize game
    function init() {
      startBtn.addEventListener('click', startGame);
      retryBtn.addEventListener('click', retryLevel);
      nextBtn.addEventListener('click', nextLevel);
      restartBtn.addEventListener('click', restartGame);
      
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      
      if (isMobile) {
        const buttonActions = {
          leftBtn: 'left',
          rightBtn: 'right',
          upBtn: 'up',
          jumpBtn: 'up',
          shootBtn: 'shoot'
        };

        Object.entries(buttonActions).forEach(([id, key]) => {
          const btn = document.getElementById(id);

          // Touch control logic
          btn.addEventListener('touchstart', () => gameState.keys[key] = true);
          btn.addEventListener('touchend', () => gameState.keys[key] = false);

          // Prevent unwanted mobile behavior
          btn.addEventListener('contextmenu', e => e.preventDefault());
          btn.addEventListener('selectstart', e => e.preventDefault());
          btn.addEventListener('touchstart', e => e.preventDefault(), { passive: false });

          // Optional: removes grey highlight on tap
          btn.style.webkitTapHighlightColor = 'transparent';
        });
      }
      
      // Initial screen setup
      showScreen(startScreen);
      deathOverlay.style.display = 'none';
    }

    // Start the game
    function startGame() {
      resetGameState();
      showScreen(gameCanvas);
      setupLevel(1);
      gameState.gameActive = true;
      requestAnimationFrame(gameLoop);
    }

    // Set up a level
    function setupLevel(level) {
      gameState.currentLevel = level;
      gameState.player = {
        x: 100,
        y: 300,
        width: 30,
        height: 30,
        velX: 0,
        velY: 0,
        speed: isMobile ? 5.0 : 3.5,
        jumpPower: -12,
        gravity: 0.5,
        friction: 0.6,
        jumping: false,
        direction: 1,
        grounded: false,
        lives: 3
      };
      gameState.collectedBrains = [];
      gameState.platforms = [];
      gameState.brains = [];
      gameState.enemies = [];
      gameState.playerProjectiles = [];
      gameState.enemyProjectiles = [];
      gameState.quizQuestions = [];
      // Only reset usedQuestions if starting a new game (level 1)
      if (level === 1) {
        gameState.usedQuestions = [];
      }
      gameState.score = { correct: 0, total: 0 };
      gameState.cameraX = 0;
      gameState.isDead = false;
      gameState.shootCooldown = 0;
      
      levelIndicator.textContent = `Level ${level}: ${gameState.levels[level-1].name}`;
      
      // Create platforms
      gameState.platforms.push({x: 0, y: 350, width: gameState.levelWidth, height: 20}); // Ground
      
      // Level-specific configurations
      if (level === 1) {
        gameState.levelWidth = 2000;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 600, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 800, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1400, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 60, height: 20});
        
        // Add 5 brains
         gameState.brains.push({x: 250, y: 250, collected: false});
  gameState.brains.push({x: 600, y: 210, collected: false});
  gameState.brains.push({x: 950, y: 250, collected: false});
  gameState.brains.push({x: 1300, y: 210, collected: false});
  gameState.brains.push({x: 1650, y: 250, collected: false});
        
        // Add enemies
        gameState.enemies.push({
          x: 500, y: 200, width: 30, height: 30, 
          velX: 1, minX: 450, maxX: 700,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1200, y: 180, width: 30, height: 30, 
          velX: -1.5, minX: 1100, maxX: 1400,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
  x: 900, y: 320, width: 30, height: 30, 
  velX: 0.8, minX: 800, maxX: 1000,
  type: 'ground',
  alive: true
});


      } else if (level === 2) {
        gameState.levelWidth = 2500;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 600, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 800, y: 200, width: 100, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1400, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 100, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 2000, y: 280, width: 100, height: 20});
        gameState.platforms.push({x: 2200, y: 340, width: 300, height: 30});
        
        // Add 5 brains
          gameState.brains.push({x: 300, y: 230, collected: false});
  gameState.brains.push({x: 750, y: 180, collected: false});
  gameState.brains.push({x: 1200, y: 230, collected: false});
  gameState.brains.push({x: 1700, y: 180, collected: false});
  gameState.brains.push({x: 2200, y: 300, collected: false});
        
        // Add enemies
        gameState.enemies.push({
          x: 600, y: 200, width: 30, height: 30, 
          velX: 1.2, minX: 500, maxX: 800,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1400, y: 180, width: 30, height: 30, 
          velX: -1.7, minX: 1300, maxX: 1600,
          type: 'ground',
          alive: true
        });
        // Vertical moving enemy
        gameState.enemies.push({
          x: 1800, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        gameState.enemies.push({
          x: 900, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
// Ranged enemy
        gameState.enemies.push({
          x: 1000, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 90, attackRange: 300,
          type: 'ranged',
          alive: true
        });
       

      } else if (level === 3) {
        gameState.levelWidth = 3000;
        
        // Add platforms
        gameState.platforms.push({x: 200, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 400, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 600, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 800, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1000, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 1200, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1400, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 1600, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 1800, y: 280, width: 70, height: 20});
        gameState.platforms.push({x: 2000, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 2200, y: 180, width: 70, height: 20});
        gameState.platforms.push({x: 2400, y: 230, width: 70, height: 20});
        gameState.platforms.push({x: 2600, y: 280, width: 200, height: 20});
        gameState.platforms.push({x: 2800, y: 340, width: 200, height: 20});

          // 5 brains (strategic placement on narrow platforms)
  gameState.brains.push({x: 250, y: 250, collected: false});
  gameState.brains.push({x: 650, y: 160, collected: false}); // Requires precise jump
  gameState.brains.push({x: 1250, y: 160, collected: false});
  gameState.brains.push({x: 1850, y: 250, collected: false});
  gameState.brains.push({x: 2350, y: 160, collected: false}); // Challenge brain

        
        // Add enemies
        gameState.enemies.push({
          x: 700, y: 150, width: 30, height: 30, 
          velX: 1.5, minX: 600, maxX: 900,
          type: 'ground',
          alive: true
        });
        gameState.enemies.push({
          x: 1500, y: 150, width: 30, height: 30, 
          velX: -1.8, minX: 1400, maxX: 1700,
          type: 'ground',
          alive: true
        });
        // Vertical moving enemy
        gameState.enemies.push({
          x: 1800, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        gameState.enemies.push({
          x: 900, y: 150, width: 30, height: 30,
          velY: 1.5, minY: 100, maxY: 250,
          type: 'vertical',
          alive: true
        });
        // Ranged enemy
        gameState.enemies.push({
          x: 2300, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 60, attackRange: 300,
          type: 'ranged',
          alive: true
        });
        gameState.enemies.push({
          x: 1100, y: 150, width: 30, height: 30, 
          velX: 0, attackTimer: 60, attackRange: 300,
          type: 'ranged',
          alive: true
        });


        } else if (level === 4) {
        gameState.levelWidth = 3000;
        
       // Level 4 - Optimized Platform Layout
gameState.platforms = [
  // Starting area
  {x: 50, y: 330, width: 220, height: 25},   // Starter platform
  {x: 320, y: 280, width: 140, height: 25},  // First slope

  // First challenge section
  {x: 520, y: 330, width: 120, height: 25},
  {x: 700, y: 280, width: 100, height: 25},  // First jump down
  {x: 900, y: 330, width: 120, height: 25},  // Landing platform

  // Middle section 
  {x: 1100, y: 280, width: 100, height: 25}, // Second jump down
  {x: 1350, y: 330, width: 120, height: 25}, // Landing

  // Upper section
  {x: 1550, y: 280, width: 100, height: 25}, // Third jump down
  {x: 1750, y: 330, width: 160, height: 25}, // Landing

  // Final stretch
  {x: 2000, y: 280, width: 130, height: 25}, // Final drop
  {x: 2300, y: 330, width: 260, height: 25}, // Main final platform
  {x: 2700, y: 330, width: 250, height: 25}  // Victory landing
];

// Strategic safety nets (only where needed)
gameState.safetyNets = [
  {x: 650, y: 420, width: 300, height: 25},  // Below first challenge
  {x: 1050, y: 420, width: 300, height: 25}, // Below middle section
  {x: 2500, y: 420, width: 500, height: 25}  // Final safety
];

// Brains placed on main path platforms
gameState.brains = [
  {x: 150, y: 300, collected: false},       // Starter
  {x: 400, y: 250, collected: false},       // First slope
  {x: 750, y: 250, collected: false},       // First challenge
  {x: 1200, y: 250, collected: false},      // Middle section
  {x: 2400, y: 300, collected: false}       // Final reward
];

// Adjusted brain positions
gameState.brains = [
  {x: 150, y: 300, collected: false},      // Starter brain
  {x: 400, y: 250, collected: false},      // Easy slope brain
  {x: 750, y: 250, collected: false},      // First challenge
  {x: 1150, y: 250, collected: false},     // Middle section
  {x: 2400, y: 300, collected: false}      // Final reward
];

// Tamer enemies
gameState.enemies = [
  {
    x: 600, y: 250, width: 35, height: 35, // Bigger hitbox = easier to avoid
    velX: 0.8, minX: 550, maxX: 750,       // Slower
    type: 'ground',
    alive: true
  },
  {
    x: 1200, y: 230, width: 35, height: 35,
    velY: 0.7, minY: 210, maxY: 270,       // Reduced range
    type: 'vertical',
    alive: true
  }
];

  } else if (level === 5) {
    gameState.levelWidth = 3200; // Slightly longer for new enemies
    
    // More aggressive platform layout with narrower platforms
    gameState.platforms = [
        // Starting area (tighter)
        {x: 50, y: 330, width: 180, height: 20},   // Starter platform
        {x: 300, y: 280, width: 100, height: 20},  // First drop (narrower)

        // First challenge section (more enemies)
        {x: 500, y: 330, width: 85, height: 20},
        {x: 700, y: 280, width: 75, height: 20},   // Precise landing
        {x: 900, y: 330, width: 80, height: 20},   // Now more dangerous

        // Middle section (added complexity)
        {x: 1100, y: 280, width: 75, height: 20},
        {x: 1350, y: 330, width: 80, height: 20},
        {x: 1550, y: 260, width: 65, height: 20},  // New low platform

        // Upper section (more vertical)
        {x: 1750, y: 210, width: 70, height: 20},
        {x: 1950, y: 290, width: 80, height: 20},  // Gap jump
        {x: 2200, y: 330, width: 100, height: 20},

        // Final stretch (more challenging)
        {x: 2500, y: 280, width: 70, height: 20},   // Platform 10
{x: 2650, y: 310, width: 60, height: 20},   // NEW mid-way platform (small, requires precision)
{x: 2800, y: 330, width: 300, height: 20},  // Platform 11 (now reachable)
    ];

    // Reduced safety nets (only critical spots)
    gameState.safetyNets = [
        {x: 800, y: 420, width: 200, height: 20},
        {x: 2600, y: 420, width: 400, height: 20}
    ];

    // Brains moved to riskier positions
    gameState.brains = [
        {x: 350, y: 250, collected: false},      // After first drop
        {x: 730, y: 250, collected: false},      // Requires enemy dodging
        {x: 1370, y: 300, collected: false},     // Above moving enemy
        {x: 1770, y: 170, collected: false},     // High-risk position
        {x: 2550, y: 250, collected: false}      // Final challenge
    ];

    // More numerous and aggressive enemies
    gameState.enemies = [
        // First section enemies
        {
            x: 400, y: 230, width: 30, height: 30,
            velX: 1.5, minX: 350, maxX: 600,
            type: 'ground',
            alive: true
        },
        {
            x: 800, y: 250, width: 30, height: 30,
            velY: 1.2, minY: 230, maxY: 350,
            type: 'vertical',
            alive: true
        },
        
        // Middle section ambush
        {
            x: 1200, y: 200, width: 25, height: 40,
            velX: 2.0, minX: 1100, maxX: 1400,
            type: 'ground',
            alive: true
        },
        {
            x: 1500, y: 210, width: 30, height: 30,
            velX: 0, attackTimer: 40, attackRange: 350,
            type: 'ranged',
            alive: true
        },
        
        // Final stretch challenges
        {
            x: 2000, y: 250, width: 30, height: 30,
            velX: 1.8, minX: 1900, maxX: 2300,
            type: 'ground',
            alive: true
        },
        {
            x: 2400, y: 200, width: 30, height: 50,
            velY: 1.5, minY: 180, maxY: 300,
            type: 'vertical',
            alive: true
        }
    ];

    // New environmental hazard
    gameState.hazards = [
        {x: 1600, y: 400, width: 400, height: 20, type: 'lava'},
        {x: 2100, y: 400, width: 300, height: 20, type: 'spikes'}
    ];

  
  } else if (level === 6) {
  gameState.levelWidth = 4000;
  
  // Platform Layout - Demanding but achievable jumps
  gameState.platforms = [
    // Starting section (warm-up)
    {x: 0, y: 380, width: 200, height: 20},
    {x: 200, y: 380, width: 100, height: 20},
    {x: 400, y: 350, width: 80, height: 20},
    
    // First challenge cluster
    {x: 600, y: 320, width: 60, height: 20},
    {x: 800, y: 290, width: 60, height: 20},  // First precision jump
    {x: 1000, y: 320, width: 80, height: 20}, // Landing after enemy gauntlet
    
    // Elevation climb
    {x: 1200, y: 280, width: 120, height: 20},
    {x: 1500, y: 240, width: 60, height: 20},
    {x: 1650, y: 200, width: 100, height: 20}, // Highest point
    
    // Descending maze
    {x: 1980, y: 240, width: 100, height: 20},
    {x: 2200, y: 280, width: 140, height: 20},
    {x: 2600, y: 320, width: 140, height: 20},
    
    // Final stretch
    {x: 3000, y: 280, width: 80, height: 20}, // Narrow platform
    {x: 3300, y: 320, width: 210, height: 20}, // Safe zone
    {x: 3600, y: 350, width: 400, height: 20}  // Exit
  ];

  // Brains - Require risk or skill
  gameState.brains = [
    {x: 820, y: 270, collected: false},  // Above first enemy cluster
    {x: 1520, y: 220, collected: false}, // At elevation peak
    {x: 2020, y: 220, collected: false}, // Descending maze
    {x: 2620, y: 300, collected: false}, // Before final stretch
    {x: 3050, y: 260, collected: false}  // Precarious final brain
  ];

  // Enemies - Enhanced from Level 5 but fair
  gameState.enemies = [
    // Fast ground patrols
    {
      x: 300, y: 310, width: 30, height: 40, // Taller hitbox
      velX: 3.0, minX: 200, maxX: 700,      // Faster
      type: 'ground',
      alive: true
    },
    {
      x: 1100, y: 280, width: 30, height: 40,
      velX: -3.0, minX: 900, maxX: 1400,
      type: 'ground',
      alive: true
    },
    
    // Vertical threats
    {
      x: 1700, y: 150, width: 30, height: 50,
      velY: 3.0, minY: 150, maxY: 300,      // Faster + extended range
      type: 'vertical',
      alive: true
    },
    {
      x: 2500, y: 150, width: 30, height: 50,
      velY: 2.8, minY: 150, maxY: 350,
      type: 'vertical',
      alive: true
    },
    
    // Ranged enemy
    {
      x: 2300, y: 200, width: 30, height: 30,
      velX: 0, attackTimer: 15, attackRange: 350, // Faster attacks
      type: 'ranged',
      alive: true
    },
    
    // Final ambush
    {
      x: 3200, y: 280, width: 40, height: 40, // Larger
      velX: 2.5, minX: 3000, maxX: 3400,
      type: 'ground',
      alive: true
    }
  ];

  // Hazards - Punish mistakes
  gameState.hazards = [
    {x: 700, y: 400, width: 600, height: 50, type: 'spikes'},  // Below first cluster
    {x: 1800, y: 400, width: 500, height: 50, type: 'lava'},   // Under elevation
    {x: 2800, y: 400, width: 800, height: 50, type: 'void'}    // Final stretch
  ];

} else if (level === 7) {
  gameState.levelWidth = 5000;
  
  // Final challenge - mix of narrow platforms and open spaces
  gameState.platforms.push({x: 200, y: 280, width: 40, height: 20});
  gameState.platforms.push({x: 400, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 600, y: 180, width: 40, height: 20});
  gameState.platforms.push({x: 900, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 1200, y: 280, width: 150, height: 20}); // Rest area
  gameState.platforms.push({x: 1500, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 1800, y: 180, width: 40, height: 20});
  gameState.platforms.push({x: 2100, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 2400, y: 280, width: 150, height: 20}); // Rest area
  gameState.platforms.push({x: 2700, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 3000, y: 180, width: 40, height: 20});
  gameState.platforms.push({x: 3300, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 3600, y: 280, width: 150, height: 20}); // Rest area
  gameState.platforms.push({x: 3900, y: 230, width: 25, height: 20}); // Hardest narrow
  gameState.platforms.push({x: 4200, y: 180, width: 40, height: 20});
  gameState.platforms.push({x: 4500, y: 280, width: 300, height: 20}); // Final platform
  gameState.platforms.push({x: 4800, y: 340, width: 200, height: 20});

  // 5 brains - all require expert platforming
  gameState.brains.push({x: 450, y: 210, collected: false}); // On very narrow platform
  gameState.brains.push({x: 950, y: 160, collected: false}); // On very narrow platform
  gameState.brains.push({x: 1550, y: 210, collected: false}); // On very narrow platform
  gameState.brains.push({x: 2750, y: 210, collected: false}); // On very narrow platform
  gameState.brains.push({x: 4650, y: 250, collected: false}); // Final brain
  
  // Ultimate enemy challenge
  gameState.enemies.push({
    x: 300, y: 150, width: 30, height: 30, 
    velX: 2.8, minX: 200, maxX: 700,
    type: 'ground',
    alive: true
  });
  gameState.enemies.push({
    x: 1100, y: 150, width: 30, height: 30, 
    velX: -2.8, minX: 900, maxX: 1500,
    type: 'ground',
    alive: true
  });
  gameState.enemies.push({
    x: 1700, y: 150, width: 30, height: 30,
    velY: 2.8, minY: 100, maxY: 250,
    type: 'vertical',
    alive: true
  });
  gameState.enemies.push({
    x: 2300, y: 150, width: 30, height: 30, 
    velX: 0, attackTimer: 15, attackRange: 450, // Lightning fast attacks
    type: 'ranged',
    alive: true
  });
  gameState.enemies.push({
    x: 2900, y: 150, width: 30, height: 30, 
    velX: 2.5, minX: 2700, maxX: 3500,
    type: 'ground',
    alive: true
  });
  gameState.enemies.push({
    x: 3500, y: 150, width: 30, height: 30,
    velY: 2.5, minY: 100, maxY: 250,
    type: 'vertical',
    alive: true
  });
  gameState.enemies.push({
    x: 4100, y: 150, width: 30, height: 30, 
    velX: 0, attackTimer: 15, attackRange: 450,
    type: 'ranged',
    alive: true
  });
      }
      
      
      // Add end flag at the end of the level
      gameState.endFlag = {x: gameState.levelWidth - 100, y: 270, width: 30, height: 80};
    }

    // Game loop
    function gameLoop() {
      if (!gameState.gameActive) return;
      
      update();
      draw();
      
      requestAnimationFrame(gameLoop);
    }

    // Update game state with fixed physics
    function update() {
      const player = gameState.player;
      
      // Player is dead - wait for respawn
      if (gameState.isDead) {
        if (gameState.keys.r) {
          respawnPlayer();
        }
        return;
      }
      
      // Apply gravity if not grounded
      if (!player.grounded) {
        player.velY += player.gravity;
      } else {
        player.velY = 0;
      }
      
      // Handle horizontal movement with friction
      if (gameState.keys.left) {
        player.velX = -player.speed;
        player.direction = -1;
      } else if (gameState.keys.right) {
        player.velX = player.speed;
        player.direction = 1;
      } else {
        player.velX *= player.friction;
        if (Math.abs(player.velX) < 0.1) player.velX = 0;
      }
      
      // Jumping - only when grounded
      if (gameState.keys.up && player.grounded) {
        player.velY = player.jumpPower;
        player.grounded = false;
      }
      
      // Shooting
      if (gameState.keys.shoot && gameState.shootCooldown <= 0) {
        gameState.playerProjectiles.push({
          x: player.x + player.width * player.direction,
          y: player.y + player.height/2,
          width: 15,
          height: 15,
          velX: 7 * player.direction,
          distance: 0,
          range: 400
        });
        gameState.shootCooldown = 60; // Cooldown frames
      }
      
      // Update position
      player.x += player.velX;
      player.y += player.velY;
      
      // Boundary checks (left/right)
      if (player.x < 0) {
        player.x = 0;
        player.velX = 0;
      }
      if (player.x > gameState.levelWidth - player.width) {
        player.x = gameState.levelWidth - player.width;
        player.velX = 0;
      }
      
      // Boundary check (bottom) - prevent falling through
      if (player.y > gameCanvas.height + 100) {
        playerDie();
        return;
      }
      
      // Improved platform collision detection
      player.grounded = false;
      for (const platform of gameState.platforms) {
        // Check if player is intersecting with platform vertically
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height >= platform.y &&
            player.y < platform.y) {
          
          // Check if player was above the platform in previous frame
          if (player.y + player.height - player.velY <= platform.y) {
            player.y = platform.y - player.height;
            player.velY = 0;
            player.grounded = true;
          }
        }
      }
      
      // Update camera position to follow player
      gameState.cameraX = player.x - gameCanvas.width / 2;
      gameState.cameraX = Math.max(0, Math.min(gameState.levelWidth - gameCanvas.width, gameState.cameraX));
      
      // Brain collection
      for (const brain of gameState.brains) {
        if (!brain.collected) {
          const dx = Math.abs(player.x + player.width/2 - (brain.x + 10));
          const dy = Math.abs(player.y + player.height/2 - (brain.y + 10));
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 20) {
            brain.collected = true;
            gameState.collectedBrains.push(brain);
            gameState.levels[gameState.currentLevel-1].collected++;
          }
        }
      }
      
      // Update enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
          // Move enemy based on type
          if (enemy.type === 'ground') {
            enemy.x += enemy.velX;
            if (enemy.x <= enemy.minX || enemy.x + enemy.width >= enemy.maxX) {
              enemy.velX *= -1;
            }
          }
          else if (enemy.type === 'vertical') {
            enemy.y += enemy.velY;
            if (enemy.y <= enemy.minY || enemy.y >= enemy.maxY) {
              enemy.velY *= -1;
            }
          }
          else if (enemy.type === 'ranged') {
            // Update attack timer
            enemy.attackTimer--;
            if (enemy.attackTimer <= 0) {
              // Calculate direction to player
              const dx = player.x - enemy.x;
              const dy = player.y - enemy.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Only shoot if player is in range
              if (distance < enemy.attackRange) {
                // Normalize direction
                const velX = dx / distance * 3;
                const velY = dy / distance * 3;
                
                // Create projectile
                gameState.enemyProjectiles.push({
                  x: enemy.x + enemy.width/2,
                  y: enemy.y + enemy.height/2,
                  width: 10,
                  height: 10,
                  velX: velX,
                  velY: velY,
                  distance: 0,
                  range: enemy.attackRange
                });
                
                // Reset attack timer
                enemy.attackTimer = 120;
              }
            }
          }
          
          // Enemy collision with player
          if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
          ) {
            // Check if player is jumping on enemy
            if (player.y + player.height < enemy.y + enemy.height/2 && player.velY > 0) {
              // Player lands on enemy
              enemy.alive = false;
              player.velY = -10; // bounce
            } else {
              // Player touched enemy from side or below
              playerDie();
              return;
            }
          }
        }
      }
      
      // Update projectiles
      updateProjectiles();
      
      // End flag collision
      if (
        player.x < gameState.endFlag.x + gameState.endFlag.width &&
        player.x + player.width > gameState.endFlag.x &&
        player.y < gameState.endFlag.y + gameState.endFlag.height &&
        player.y + player.height > gameState.endFlag.y
      ) {
        endLevel();
      }
      
      // Update shoot cooldown
      if (gameState.shootCooldown > 0) {
        gameState.shootCooldown--;
      }
    }
    
    // Update projectiles
    function updateProjectiles() {
      // Player projectiles
      for (let i = gameState.playerProjectiles.length - 1; i >= 0; i--) {
        const p = gameState.playerProjectiles[i];
        p.x += p.velX;
        p.distance += Math.abs(p.velX);
        
        // Check enemy collisions
        let hit = false;
        for (const enemy of gameState.enemies) {
          if (enemy.alive && 
              p.x < enemy.x + enemy.width &&
              p.x + p.width > enemy.x &&
              p.y < enemy.y + enemy.height &&
              p.y + p.height > enemy.y) {
            enemy.alive = false;
            hit = true;
            break;
          }
        }
        
        // Remove projectiles that hit or exceed range
        if (hit || p.distance > p.range) {
          gameState.playerProjectiles.splice(i, 1);
        }
      }
      
      // Enemy projectiles
      for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
        const p = gameState.enemyProjectiles[i];
        p.x += p.velX;
        p.y += p.velY;
        p.distance += Math.sqrt(p.velX * p.velX + p.velY * p.velY);
        
        // Check player collision
        const player = gameState.player;
        if (p.x < player.x + player.width &&
            p.x + p.width > player.x &&
            p.y < player.y + player.height &&
            p.y + p.height > player.y) {
          playerDie();
          gameState.enemyProjectiles.splice(i, 1);
        } 
        // Remove projectiles that exceed range
        else if (p.distance > p.range) {
          gameState.enemyProjectiles.splice(i, 1);
        }
      }
    }

    function playerDie() {
      if (gameState.player.lives <= 0) return;

      gameState.player.lives--;

      if (gameState.player.lives <= 0) {
        gameState.player.lives = 0;
        showRestartMessage("üíÄ Out of lives! Restarting level...");

        setTimeout(() => {
          // Reset player state
          gameState.player.lives = 3;
          gameState.player.brains = 0;
          gameState.brainsCollected = 0;
          gameState.collectedBrains = [];

          // ‚úÖ Safely reset visual counter only if it's visible
          const counterEl = document.getElementById("collectedCount");
          if (counterEl) counterEl.textContent = "0";

          gameState.quizUnlocked = false;
          gameState.brainsNeeded = (gameState.level === 3) ? 15 : 10;

          // Reset player position and velocity
          const player = gameState.player;
          player.x = 100;
          player.y = 300;
          player.velX = 0;
          player.velY = 0;
          player.grounded = false;

          // Reset collected brains
          gameState.brains.forEach(brain => brain.collected = false);

          hideRestartMessage();
          setupLevel(gameState.currentLevel);
        }, 2000);

      } else {
        respawnPlayer();
      }
    }

    function showRestartMessage(message) {
      let msg = document.getElementById('restartMessage');
      if (!msg) {
        msg = document.createElement('div');
        msg.id = 'restartMessage';
        msg.style.position = 'absolute';
        msg.style.top = '40%';
        msg.style.left = '50%';
        msg.style.transform = 'translate(-50%, -50%)';
        msg.style.background = '#fff';
        msg.style.border = '2px solid #000';
        msg.style.padding = '20px';
        msg.style.fontSize = '20px';
        msg.style.zIndex = 1000;
        msg.style.color = '#000';
        msg.style.maxWidth = '90%';
        msg.style.textAlign = 'center';
        document.body.appendChild(msg);
      }
      msg.textContent = message;
      msg.style.display = 'block';
    }

    function hideRestartMessage() {
      const msg = document.getElementById('restartMessage');
      if (msg) msg.style.display = 'none';
    }

    function respawnPlayer() {
      const player = gameState.player;
      player.x = 100;
      player.y = 300;
      player.velX = 0;
      player.velY = 0;
      player.grounded = false;
      gameState.isDead = false;
      deathOverlay.style.opacity = '0';
      setTimeout(() => {
        deathOverlay.style.display = 'none';
      }, 300);
    }

    // Draw everything
    function draw() {
      const cameraX = gameState.cameraX;
      
      // Clear canvas
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      
        // Draw background - pass current level (assuming you track this in gameState)
  drawBackground(cameraX, gameState.currentLevel);
      
      // Draw platforms
      ctx.fillStyle = '#8B4513';
      for (const platform of gameState.platforms) {
        ctx.fillRect(platform.x - cameraX, platform.y, platform.width, platform.height);
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(platform.x - cameraX, platform.y, platform.width, 5);
        ctx.fillStyle = '#8B4513';
      }
      
      // Draw brains
      for (const brain of gameState.brains) {
        if (!brain.collected) {
          ctx.fillStyle = '#FF66CC';
          ctx.beginPath();
          ctx.arc(brain.x - cameraX + 10, brain.y + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw brain details
          ctx.fillStyle = '#FF99DD';
          ctx.beginPath();
          ctx.arc(brain.x - cameraX + 6, brain.y + 8, 3, 0, Math.PI * 2);
          ctx.arc(brain.x - cameraX + 14, brain.y + 8, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw enemies
      for (const enemy of gameState.enemies) {
        if (enemy.alive) {
          // Draw enemy based on type
          if (enemy.type === 'ground' || enemy.type === 'vertical') {
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.width, enemy.height);
            
            // Draw enemy eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            const eyeOffset = (enemy.type === 'ground' && enemy.velX > 0) ? 8 : 2;
            ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - eyeOffset, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          else if (enemy.type === 'ranged') {
            // Draw ranged enemy (different color)
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.width, enemy.height);
            
            // Draw enemy eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + 15, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - 15, enemy.y + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(enemy.x - cameraX + 15, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.arc(enemy.x - cameraX + enemy.width - 15, enemy.y + 10, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Draw projectiles
 // Player projectiles (fixed version)
for (const p of gameState.playerProjectiles) {
  // Darker blue-teal gradient
  const gradient = ctx.createRadialGradient(
    p.x - cameraX, p.y, 0,
    p.x - cameraX, p.y, p.width/2
  );
  gradient.addColorStop(0, 'rgba(0, 150, 200, 0.9)');  // Darker center
  gradient.addColorStop(0.7, 'rgba(0, 100, 150, 0.8)'); // Mid tone
  gradient.addColorStop(1, 'rgba(0, 80, 120, 0.6)');   // Darker edge

  // Main bubble
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Thicker dark outline
  ctx.strokeStyle = 'rgba(0, 60, 90, 0.9)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.stroke();
  
  // Smaller, subtle highlight (FIXED: changed 'y' to 'p.y')
  ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
  ctx.beginPath();
  ctx.arc(
    p.x - cameraX - p.width/6, 
    p.y - p.height/6,  // This was the problematic line - now fixed
    p.width/5,
    0, 
    Math.PI * 2
  );
  ctx.fill();
}

// Enemy projectiles (darker and more ominous)
for (const p of gameState.enemyProjectiles) {
  // Dark red gradient
  const gradient = ctx.createRadialGradient(
    p.x - cameraX, p.y, 0,
    p.x - cameraX, p.y, p.width/2
  );
  gradient.addColorStop(0, 'rgba(180, 0, 0, 0.9)');   // Blood red center
  gradient.addColorStop(0.7, 'rgba(120, 0, 0, 0.8)'); // Dark red mid
  gradient.addColorStop(1, 'rgba(80, 0, 0, 0.6)');    // Very dark edge

  // Main projectile
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Pulsing dark outline
  const pulseSize = Math.sin(Date.now()/100) * 1.5;
  ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(
    p.x - cameraX, 
    p.y, 
    p.width/2 + pulseSize, 
    0, 
    Math.PI * 2
  );
  ctx.stroke();
  
  // Dark core for contrast
  ctx.fillStyle = 'rgba(50, 0, 0, 0.7)';
  ctx.beginPath();
  ctx.arc(p.x - cameraX, p.y, p.width/4, 0, Math.PI * 2);
  ctx.fill();
}
      
      // Draw end flag
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(gameState.endFlag.x - cameraX, gameState.endFlag.y, 5, gameState.endFlag.height);
      
      ctx.fillStyle = '#2196F3';
      ctx.beginPath();
      ctx.moveTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y);
      ctx.lineTo(gameState.endFlag.x - cameraX + 25, gameState.endFlag.y + 15);
      ctx.lineTo(gameState.endFlag.x - cameraX + 5, gameState.endFlag.y + 30);
      ctx.closePath();
      ctx.fill();
      
      // Draw player (tadpole) with fixed direction
      const player = gameState.player;
      const drawX = player.x - cameraX;
      const drawY = player.y;
      
      ctx.fillStyle = '#4CAF50';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/2, 
        drawY + player.height/2, 
        player.width/2, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Draw tail with wiggle
      ctx.beginPath();
      const now = performance.now();
      const isMoving = gameState.keys.left || gameState.keys.right;
      const tailDirection = -player.direction || 1;
      const wiggleY = isMoving ? Math.sin(now / 100) * 5 : 0;
      const baseX = drawX + player.width / 2 + tailDirection * player.width / 2;
      const baseY = drawY + player.height / 2 + wiggleY;
      
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX + tailDirection * player.width / 2, baseY);
      ctx.lineTo(baseX + tailDirection * player.width / 3, drawY + player.height + wiggleY);
      ctx.closePath();
      ctx.fill();
      
      // Draw eyes
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/3 + (player.direction > 0 ? player.width/3 : 0), 
        drawY + player.height/3, 
        4, 0, Math.PI * 2
      );
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(
        drawX + player.width/3 + (player.direction > 0 ? player.width/3 : 0), 
        drawY + player.height/3, 
        2, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Draw collected brain counter
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Brains: ${gameState.collectedBrains.length}/${gameState.levels[gameState.currentLevel-1].brains}`, 20, 35);
      
      // Draw level indicator
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width - 190, 10, 180, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Level: ${gameState.currentLevel}`, gameCanvas.width - 180, 35);
      
      // Draw lives
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(gameCanvas.width/2 - 60, 10, 120, 40);
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Lives: ${gameState.player.lives}`, gameCanvas.width/2 - 50, 35);
    }

    function drawBackground(cameraX, level) {
  switch(level) {
    // Level 1: Underwater (introduction)
    case 1:
      drawUnderwaterBackground(cameraX, true); // Brighter version
      break;
      // Level 2: Forest (gentle rain)
    case 2:
      drawForestBackground(cameraX);
      break;
      
    // Level 3: Alien Planet (surreal)
    case 3:
      drawAlienBackground(cameraX);
      break;
      
    // Level 4: Volcanic Cavern (lava)
    case 4:
      drawVolcanoBackground(cameraX);
      break;
      
    // Level 5: Night City (contrast)
    case 5:
      drawCityBackground(cameraX);
      break;
      
    // Level 6: Sunny Default (calm before finale)
    case 6:
      drawBackground(cameraX);
      break;
      
    // Level 7: Deep Underwater (finale, darker)
    case 7:
      drawUnderwaterBackground(cameraX, false); // Darker version
      break;
      
    default: // Fallback
      drawUnderwaterBackground(cameraX); // Default underwater
 
    
    // Original background code (renamed from your existing drawBackground)
    // Sky gradient
   
    const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
    skyGradient.addColorStop(0, '#87CEEB');
    skyGradient.addColorStop(1, '#E0F7FA');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    // Clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    drawCloud(100 - cameraX/3, 50);
    drawCloud(300 - cameraX/3, 80);
    drawCloud(500 - cameraX/3, 60);
    drawCloud(700 - cameraX/3, 70);
    drawCloud(900 - cameraX/3, 65);
    drawCloud(1100 - cameraX/3, 55);
    
    // Sun rays
    const sunX = 700;
    const sunY = 80;
    const rayLength = 60;
    const rayCount = 12;
    
    ctx.strokeStyle = 'rgba(255, 235, 59, 0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i < rayCount; i++) {
      const angle = (Math.PI * 2 / rayCount) * i;
      const startX = sunX + Math.cos(angle) * 45;
      const startY = sunY + Math.sin(angle) * 45;
      const endX = sunX + Math.cos(angle) * (45 + rayLength);
      const endY = sunY + Math.sin(angle) * (45 + rayLength);
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    }
    
    // Sun body
    ctx.fillStyle = '#FFEB3B';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 40, 0, Math.PI * 2);
    ctx.fill();
    
    // Distant hills
    ctx.fillStyle = 'rgba(144, 238, 144, 0.6)';
    ctx.beginPath();
    ctx.moveTo(0 - cameraX/4, 350);
    for (let i = 0; i < 10; i++) {
      ctx.lineTo(i * 200 - cameraX/4, 300 - Math.sin(i) * 30);
    }
    ctx.lineTo(2000, 350);
    ctx.lineTo(0, 350);
    ctx.fill();
  }
}

    // Draw a cloud
    function drawCloud(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.arc(x + 15, y - 10, 15, 0, Math.PI * 2);
      ctx.arc(x + 30, y, 20, 0, Math.PI * 2);
      ctx.arc(x + 15, y + 10, 15, 0, Math.PI * 2);
      ctx.fill();
    }

// Underwater background
function drawUnderwaterBackground(cameraX) {
  // Water gradient (darker at depth, lighter near surface)
  const waterGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  waterGradient.addColorStop(0, '#1a6a8a');  // Surface
  waterGradient.addColorStop(1, '#0a2e38');  // Depth
  ctx.fillStyle = waterGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
  
  // Light rays from surface
  ctx.strokeStyle = 'rgba(173, 216, 230, 0.3)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 5; i++) {
    const x = 150 + i * 300 - cameraX * 0.2;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + 50, gameCanvas.height);
    ctx.stroke();
  }
  
  // Bubbles (rising effect with camera)
  ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
  for (let i = 0; i < 15; i++) {
    const bubbleX = (i * 120 + (cameraX * 0.4)) % 1400;
    const bubbleY = (gameCanvas.height - (Date.now() * 0.05 + i * 40) % (gameCanvas.height + 50));
    const size = 3 + Math.sin(Date.now() * 0.001 + i) * 2;
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Seaweed (foreground plants)
  ctx.fillStyle = '#2a7a3a';
  for (let i = 0; i < 8; i++) {
    drawSeaweed(200 + i * 180 - cameraX * 0.8, gameCanvas.height - 30);
  }
  
  // Coral reef (distant)
  ctx.fillStyle = 'rgba(205, 92, 92, 0.7)';
  ctx.beginPath();
  ctx.moveTo(0 - cameraX/5, gameCanvas.height - 50);
  for (let i = 0; i < 15; i++) {
    const x = i * 150 - cameraX/5;
    const height = 30 + Math.sin(i * 0.5) * 20;
    ctx.lineTo(x, gameCanvas.height - 50 - height);
  }
  ctx.lineTo(2000, gameCanvas.height - 50);
  ctx.fill();
}

// Draw seaweed plant
function drawSeaweed(x, y) {
  ctx.beginPath();
  // Main stem
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x + 10, y - 60, x - 10, y - 120, x, y - 180);
  
  // Leaves
  for (let i = 0; i < 5; i++) {
    const leafY = y - 30 - i * 30;
    ctx.moveTo(x, leafY);
    ctx.quadraticCurveTo(x + 15 + i * 3, leafY - 15, x, leafY - 30);
    ctx.moveTo(x, leafY);
    ctx.quadraticCurveTo(x - 15 - i * 3, leafY - 15, x, leafY - 30);
  }
  ctx.strokeStyle = '#2a7a3a';
  ctx.lineWidth = 3;
  ctx.stroke();
}

function drawCityBackground(cameraX) {
  // Night sky gradient
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#0a0a2a');
  skyGradient.addColorStop(1, '#1a1a40');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Stars
  ctx.fillStyle = 'white';
  for (let i = 0; i < 100; i++) {
    const x = (i * 50 + cameraX * 0.1) % (gameCanvas.width + 200);
    const y = (i * 30) % gameCanvas.height;
    const size = Math.random() * 1.5;
    ctx.fillRect(x, y, size, size);
  }

  // Distant buildings (parallax)
  ctx.fillStyle = '#222244';
  for (let i = 0; i < 15; i++) {
    const width = 80 + Math.sin(i) * 20;
    const height = 100 + Math.cos(i * 0.7) * 50;
    ctx.fillRect(
      i * 150 - cameraX * 0.3, 
      gameCanvas.height - height,
      width, 
      height
    );
  }

  // Closer buildings
  ctx.fillStyle = '#333366';
  for (let i = 0; i < 10; i++) {
    const height = 200 + Math.sin(i) * 40;
    ctx.fillRect(
      i * 200 - cameraX * 0.7, 
      gameCanvas.height - height,
      120, 
      height
    );
  }

  // Windows (yellow lights)
  ctx.fillStyle = 'rgba(255, 215, 0, 0.4)'; // More transparent gold
for (let i = 0; i < 20; i++) { // Fewer windows
  const x = (i * 150 + cameraX * 0.5) % 2000;
  const y = gameCanvas.height - 30 - (Math.floor(i / 4) * 50); // More spaced out
  if (Math.random() > 0.5) { // 50% chance to draw a window
    ctx.fillRect(x, y, 10, 15); // Smaller windows
  }
}
}

function drawVolcanoBackground(cameraX) {
  // Cave gradient (dark red to black)
  const caveGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  caveGradient.addColorStop(0, '#3a0a0a');
  caveGradient.addColorStop(1, '#000000');
  ctx.fillStyle = caveGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Lava river at bottom
  const lavaGradient = ctx.createLinearGradient(0, gameCanvas.height - 50, 0, gameCanvas.height);
  lavaGradient.addColorStop(0, '#ff4500');
  lavaGradient.addColorStop(1, '#ff8c00');
  ctx.fillStyle = lavaGradient;
  ctx.fillRect(0, gameCanvas.height - 30, gameCanvas.width, 30);

  // Lava bubbles
  ctx.fillStyle = '#ff6600';
  for (let i = 0; i < 8; i++) {
    const x = (i * 200 + cameraX * 0.4) % (gameCanvas.width + 300);
    const y = gameCanvas.height - 35 + Math.sin(Date.now() * 0.002 + i) * 3;
    ctx.beginPath();
    ctx.arc(x, y, 10 + Math.sin(Date.now() * 0.001 + i) * 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Stalactites
  ctx.fillStyle = '#555555';
  for (let i = 0; i < 20; i++) {
    const x = i * 150 - cameraX * 0.6;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + 15, 0);
    ctx.lineTo(x + 7, 40 + Math.sin(i) * 20);
    ctx.closePath();
    ctx.fill();
  }
}

function drawAlienBackground(cameraX) {
  // Sky gradient (purple to pink)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#4b0082');
  skyGradient.addColorStop(1, '#ff1493');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // Floating alien orbs
  ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
  for (let i = 0; i < 6; i++) {
    const x = (i * 250 + cameraX * 0.2) % (gameCanvas.width + 400);
    const y = 100 + Math.sin(Date.now() * 0.001 + i) * 30;
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.fill();
  }

  // Strange plants
  ctx.fillStyle = '#7cfc00';
  for (let i = 0; i < 10; i++) {
    const x = i * 200 - cameraX * 0.5;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.bezierCurveTo(
      x + 50, gameCanvas.height - 120,
      x - 50, gameCanvas.height - 180,
      x, gameCanvas.height - 220
    );
    ctx.lineWidth = 8;
    ctx.stroke();
  }

  // Twin moons
  ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
  ctx.beginPath();
  ctx.arc(150 - cameraX * 0.05, 80, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255, 100, 255, 0.5)';
  ctx.beginPath();
  ctx.arc(300 - cameraX * 0.03, 60, 40, 0, Math.PI * 2);
  ctx.fill();
}
function drawForestBackground(cameraX) {
  // Sky gradient (darker for contrast)
  const skyGradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
  skyGradient.addColorStop(0, '#001f27');
  skyGradient.addColorStop(1, '#0d0020');
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

  // === GENTLE VERTICAL RAIN === //
  ctx.strokeStyle = 'rgba(180, 235, 255, 0.4)';
  ctx.lineWidth = 1.2;
  const rainDrops = 80; // Reduced quantity for subtlety
  
  for (let i = 0; i < rainDrops; i++) {
    const rainX = (i * 25 + cameraX * 0.1) % (gameCanvas.width + 50);
    const rainProgress = (Date.now() * 0.2 + i * 50) % (gameCanvas.height + 100);
    const rainY = rainProgress - 100; // Start above canvas
    
    // Only draw if visible
    if (rainY > -10 && rainY < gameCanvas.height) {
      const opacity = Math.min(1, rainProgress / 100) * 0.4; // Fade in at top
      const length = 12 + Math.sin(i) * 4; // Subtle variation
      
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.moveTo(rainX, rainY);
      ctx.lineTo(rainX, rainY + length);
      ctx.stroke();
      ctx.restore();
    }
  }

  // === VARIED TREES === //
  const treeTypes = [
    // Type 1: Willow-style
    { color: '#00a896', draw: (x) => {
      ctx.fillStyle = '#5e503f';
      ctx.fillRect(x, gameCanvas.height - 100, 25, 100);
      ctx.fillStyle = '#00a896';
      for (let j = 0; j < 8; j++) {
        ctx.beginPath();
        ctx.moveTo(x + 12, gameCanvas.height - 100 + j * 5);
        ctx.quadraticCurveTo(
          x + 30 - j * 4, gameCanvas.height - 130 - j * 15,
          x + 50 - j * 8, gameCanvas.height - 80 - j * 5
        );
        ctx.lineTo(x - 26 + j * 8, gameCanvas.height - 80 - j * 5);
        ctx.quadraticCurveTo(
          x - 6 + j * 4, gameCanvas.height - 130 - j * 15,
          x + 12, gameCanvas.height - 100 + j * 5
        );
        ctx.fill();
      }
    }},
    
    // Type 2: Pine-style
    { color: '#02c39a', draw: (x) => {
      ctx.fillStyle = '#4a4e41';
      ctx.fillRect(x, gameCanvas.height - 120, 20, 120);
      for (let j = 0; j < 3; j++) {
        ctx.fillStyle = `rgba(2, 195, 154, ${0.7 - j * 0.2})`;
        ctx.beginPath();
        ctx.moveTo(x + 10, gameCanvas.height - 180 + j * 40);
        ctx.lineTo(x + 40 - j * 10, gameCanvas.height - 120 + j * 20);
        ctx.lineTo(x - 20 + j * 10, gameCanvas.height - 120 + j * 20);
        ctx.closePath();
        ctx.fill();
      }
    }},
    
    // Type 3: Glowing mushroom trees
    { color: '#ff6b6b', draw: (x) => {
      ctx.fillStyle = '#69385c';
      ctx.fillRect(x, gameCanvas.height - 80, 15, 80);
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(x + 7, gameCanvas.height - 100, 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      for (let j = 0; j < 5; j++) {
        ctx.beginPath();
        ctx.arc(
          x + 7 + Math.cos(j * 1.2) * 20,
          gameCanvas.height - 100 + Math.sin(j * 1.2) * 20,
          3 + Math.sin(Date.now() * 0.005 + j) * 2,
          0, Math.PI * 2
        );
        ctx.fill();
      }
    }}
  ];

  // Draw 8 trees with parallax
  for (let i = 0; i < 8; i++) {
    const treeType = treeTypes[i % treeTypes.length];
    const x = i * 300 - cameraX * 0.6;
    if (x > -200 && x < gameCanvas.width + 200) {
      treeType.draw(x);
    }
  }

  // === FOREGROUND FOLIAGE === //
  ctx.fillStyle = 'rgba(0, 168, 150, 0.3)';
  for (let i = 0; i < 40; i++) {
    const x = (i * 100 - cameraX * 0.9) % (gameCanvas.width + 400);
    const height = 30 + Math.sin(i) * 15;
    ctx.beginPath();
    ctx.moveTo(x, gameCanvas.height);
    ctx.lineTo(x + 20, gameCanvas.height - height);
    ctx.lineTo(x - 10, gameCanvas.height - height * 0.7);
    ctx.closePath();
    ctx.fill();
  }
}

    // End level and show quiz
    function endLevel() {
      gameState.gameActive = false;
      showScreen(quizScreen);


      // Reset quiz questions for this session
      gameState.quizQuestions = [];

      // Get the appropriate question bank
      let bank;
      if (gameState.currentLevel <= 2) bank = questionBanks.easy;       // Levels 1-2: Easy
      else if (gameState.currentLevel <= 4) bank = questionBanks.medium; // Levels 3-4: Medium 
      else bank = questionBanks.hard; 

      // Get random questions - now uses 5 questions max per level
      const maxQuestions = 5; // Since each level has 5 brains
      const numQuestions = Math.min(gameState.collectedBrains.length, maxQuestions);


      // Filter out questions already used in previous levels
      const availableQuestions = bank.filter(q => !gameState.usedQuestions.includes(q));

      for (let i = 0; i < numQuestions; i++) {
        if (availableQuestions.length === 0) break;
        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
        const selected = availableQuestions[randomIndex];
        gameState.quizQuestions.push(selected);
        gameState.usedQuestions.push(selected);
        availableQuestions.splice(randomIndex, 1);
      }

      gameState.score.total = gameState.quizQuestions.length;
      gameState.currentQuestion = 0;

      collectedCount.textContent = gameState.collectedBrains.length;
      showQuestion();
    }

    // Show current question
    function showQuestion() {
      if (gameState.currentQuestion >= gameState.quizQuestions.length) {
        showScoreScreen();
        return;
      }
      
      const question = gameState.quizQuestions[gameState.currentQuestion];
      questionText.textContent = question.question;
      
      optionsContainer.innerHTML = '';
      question.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.className = 'optionBtn';
        button.textContent = option;
        button.dataset.index = index;
        button.addEventListener('click', () => checkAnswer(index, question.answer, button));
        if (isMobile) {
          button.addEventListener('touchstart', () => checkAnswer(index, question.answer, button));
        }
        optionsContainer.appendChild(button);
      });
    }

    // Check if answer is correct
    function checkAnswer(selected, correct, button) {
      // Disable all buttons
      const buttons = optionsContainer.querySelectorAll('.optionBtn');
      buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.cursor = 'default';
      });
      
      // Mark correct and incorrect
      if (selected === correct) {
        button.classList.add('correct');
        gameState.score.correct++;
      } else {
        button.classList.add('incorrect');
        // Also highlight correct answer
        buttons[correct].classList.add('correct');
      }
      
      // Move to next question after delay
      setTimeout(() => {
        gameState.currentQuestion++;
        showQuestion();
      }, 1500);
    }

    function showScoreScreen() {
      showScreen(scoreScreen);

      const correct = gameState.score.correct;
      const total = gameState.score.total;
      const percentage = Math.round((correct / total) * 100);

      scoreSummary.textContent = `You scored ${correct}/${total} (${percentage}%) on the ${gameState.levels[gameState.currentLevel - 1].name} quiz!`;

      if (gameState.currentLevel === 7) {
        // Immediately hide score screen and show final screen
        setTimeout(() => {
          showScreen(finalScreen);
          finalText.textContent =
            `üéì You've completed all 7 levels!\n` +
            `Final Score: ${correct}/${total} (${percentage}%)\n\n` +
            `Thanks for playing Tadpole Trials!\nGood luck with your Biology studies! üß†üìò`;
        }, 1500);
      } else {
        nextBtn.style.display = 'inline-block';
      }
    }

    // Retry current level
    function retryLevel() {
      showScreen(gameCanvas);
      setupLevel(gameState.currentLevel);
      gameState.gameActive = true;
      requestAnimationFrame(gameLoop);
    }

    // Go to next level
    function nextLevel() {
      if (gameState.currentLevel < 7) {
        setupLevel(gameState.currentLevel + 1);
        showScreen(gameCanvas);
        gameState.gameActive = true;
        requestAnimationFrame(gameLoop);
      } else {
        showFinalScreen();
      }
    }

    // Show final screen
    function showFinalScreen() {
      showScreen(finalScreen);
    }

    // Restart game
    function restartGame() {
      showScreen(startScreen);
    }

    // Reset game state
    function resetGameState() {
      gameState.currentLevel = 1;
      gameState.levels.forEach(level => {
        level.collected = 0;
      });
    }

    // Handle key down
    function handleKeyDown(e) {
      if (!gameState.gameActive) return;
      
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = true;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = true;
      } else if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && gameState.player.grounded) {
        gameState.keys.up = true;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = true;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = true;
      }
    }

    // Handle key up
    function handleKeyUp(e) {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        gameState.keys.left = false;
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        gameState.keys.right = false;
      } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        gameState.keys.up = false;
      } else if (e.key === 'r' || e.key === 'R') {
        gameState.keys.r = false;
      } else if (e.key === 'f' || e.key === 'F') {
        gameState.keys.shoot = false;
      }
    }

   // Question banks
    const questionBanks = {
      easy: [
        {
          question: "What is the basic unit of life?",
          options: ["Atom", "Cell", "Tissue", "Organelle"],
          answer: 1
        },
        {
          question: "Which molecule carries genetic information?",
          options: ["Protein", "DNA", "Lipid", "ATP"],
          answer: 1
        },
        {
          question: "What is the role of mRNA?",
          options: ["Cuts DNA", "Synthesises proteins", "Carries genetic code from DNA to ribosome", "Produces glucose"],
          answer: 2
        },
        {
          question: "Which organelle is the site of protein synthesis?",
          options: ["Golgi apparatus", "Nucleus", "Ribosome", "Lysosome"],
          answer: 2
        },
        {
          question: "Which stage of cellular respiration produces 2 ATP?",
          options: ["Glycolysis", "Electron Transport Chain", "Light-dependent stage", "Photosystem II"],
          answer: 0
        },
        {
          question: "What gas do plants take in for photosynthesis?",
          options: ["Oxygen", "Carbon dioxide", "Hydrogen", "Methane"],
          answer: 1
        },
        {
          question: "Which type of immunity results from a vaccine?",
          options: ["Natural passive", "Natural active", "Artificial passive", "Artificial active"],
          answer: 3
        },
        {
          question: "Which barrier prevents pathogen entry in plants?",
          options: ["Skin", "Waxy cuticle", "White blood cells", "Platelets"],
          answer: 1
        },
        {
          question: "What is an intron?",
          options: ["A protein", "A coding region of DNA", "A non-coding region of a gene", "A ribosome"],
          answer: 2
        },
        {
          question: "Which stage in photosynthesis produces glucose?",
          options: ["Light-dependent", "Light-independent", "Krebs cycle", "Electron transport chain"],
          answer: 1
        }
      ],
      medium: [
        {
          question: "Which RNA molecule brings amino acids to the ribosome?",
          options: ["mRNA", "rRNA", "tRNA", "siRNA"],
          answer: 2
        },
        {
          question: "What is a bioethical concern of GM crops?",
          options: ["Low yields", "Misuse of fertilizers", "Unintended environmental impacts", "Inability to photosynthesise"],
          answer: 2
        },
        {
          question: "Which part of a gene is involved in regulation?",
          options: ["Exon", "Promoter", "Intron", "tRNA"],
          answer: 1
        },
        {
          question: "Which statement describes the universal nature of the genetic code?",
          options: ["All organisms use different codons", "Codons are randomly assigned", "All organisms share the same codon meanings", "Codons change across species"],
          answer: 2
        },
        {
          question: "What role do coenzymes like NADH play in respiration?",
          options: ["Provide energy", "Carry hydrogen/electrons", "Break down glucose", "Form cell membranes"],
          answer: 1
        },
        {
          question: "What is a key difference between CRISPR-Cas9 and restriction enzymes?",
          options: ["Only CRISPR-Cas9 can cut DNA", "Restriction enzymes are programmable", "CRISPR-Cas9 can be directed to any DNA sequence using RNA", "Restriction enzymes are found in eukaryotes"],
          answer: 2
        },
        {
          question: "Which factor would most decrease enzyme activity?",
          options: ["Slight temperature increase", "Optimal pH", "Low substrate concentration", "Presence of a non-competitive inhibitor"],
          answer: 3
        },
        {
          question: "What defines herd immunity?",
          options: ["Only unvaccinated individuals are protected", "Enough individuals are immune to prevent spread", "The disease has been eradicated", "All people must be vaccinated"],
          answer: 1
        },
        {
          question: "What does a phylogenetic tree show?",
          options: ["Protein function", "Organ growth", "Genetic relatedness", "Food webs"],
          answer: 2
        },
        {
          question: "Why might mtDNA be used in evolutionary studies?",
          options: ["It mutates slowly", "It's inherited maternally and mutates rapidly", "It can't be extracted", "It encodes traits like height"],
          answer: 1
        }
      ],
      hard: [
        {
          question: "In the CRISPR-Cas9 system, where must the PAM be located relative to the DNA sequence targeted by the single-guide RNA?",
          options: [
            "Upstream (5‚Ä≤ side) on the target strand",
            "Downstream (3‚Ä≤ side) on the non-target strand",
            "Anywhere within 20 bp on either strand",
            "Within the guide RNA itself"
          ],
          answer: 1
        },
        {
          question: "A bacterium has high tryptophan levels but its trp repressor cannot bind the operator. Which mechanism will still reduce transcription of the structural genes?",
          options: [
            "Inducer exclusion",
            "Catabolite repression",
            "Attenuation via formation of a terminator hairpin",
            "Antisense RNA"
          ],
          answer: 2
        },
        {
          question: "Why does the trp operon show a low basal (leaky) transcription rate even when the active repressor is bound?",
          options: [
            "RNA polymerase can never bind",
            "The repressor periodically dissociates, allowing short bursts of initiation",
            "Attenuation fails at high tryptophan",
            "Tryptophan is rapidly degraded"
          ],
          answer: 1
        },
        {
          question: "How do monoclonal antibodies function when used as an antivenom for snake bites?",
options: [
  "They activate memory B cells to produce specific antibodies.",
  "They neutralise venom toxins by binding to them directly.",
  "They stimulate cytotoxic T cells to destroy venom-infected cells.",
  "They trigger inflammation to remove venom from tissues."
],
answer: 1
        },
        {
          question: "Why does the total ATP yield from aerobic respiration range between 26 and 28 molecules per glucose?",
options: [
  "FADH‚ÇÇ produces more ATP than NADH in the electron transport chain",
  "Cytosolic NADH transfers electrons via different shuttles, affecting whether they reduce FAD or NAD‚Å∫",
  "The number of CO‚ÇÇ molecules produced varies",
  "Oxygen availability changes the number of protons pumped"
],
answer: 1
        },
        {
          question: "Which correctly contrasts C‚ÇÑ and CAM plants in limiting photorespiration?",
          options: [
            "C‚ÇÑ separates Calvin cycle by time; CAM by space",
            "C‚ÇÑ fixes CO‚ÇÇ at night; CAM in bundle-sheath cells",
            "C‚ÇÑ uses PEP-carboxylase in mesophyll cells; CAM stores fixed CO‚ÇÇ as malate at night for daytime Calvin cycle",
            "Both run Calvin cycle at night"
          ],
          answer: 2
        },
        {
          question: "During alcoholic fermentation, decarboxylation of pyruvate directly produces:",
          options: [
            "Acetyl-CoA",
            "Ethanol",
            "CO‚ÇÇ and acetaldehyde",
            "Lactate"
          ],
          answer: 2
        },
        {
          question: "During PCR, why does the DNA polymerase remain active at high temperatures?",
          options: [
            "It is re-added after each cycle",
            "It is sourced from a thermophilic organism such as Thermus aquaticus",
            "The buffer neutralises heat",
            "DNA primers stabilise the enzyme"
          ],
          answer: 1
        },
        {
          question: "Which of the following is true about MHC class I and MHC class II molecules?",
          options: [
            "MHC I presents extracellular antigens to B cells",
            "MHC II is found on all nucleated cells",
            "MHC I presents intracellular peptides to cytotoxic T cells",
            "MHC II activates cytotoxic T cells"
          ],
          answer: 2
        },
        {
          question: "A viral peptide presented on MHC II of a dendritic cell will be recognised by which lymphocyte, and what is the immediate outcome?",
          options: [
            "Cytotoxic T ‚Üí apoptosis",
            "Helper T ‚Üí activation & cytokine release",
            "B cell ‚Üí antibody secretion",
            "NK cell ‚Üí perforin release"
          ],
          answer: 1
        },
        {
          question: "Why do scientists use insulin cDNA instead of the full human insulin gene when inserting it into E. coli for protein production?",
options: [
  "cDNA contains bacterial promoters needed for transcription",
  "The full human gene contains introns that E. coli cannot process",
  "cDNA is circular like a plasmid",
  "The human gene lacks a ribosome-binding site"
],
answer: 1
        },
        {
          question: "Why is the proteome considered more complex than the genome in a multicellular organism?",
options: [
  "The proteome includes all non-coding DNA elements",
  "A single gene can give rise to multiple proteins via alternative splicing and post-translational modifications",
  "Proteins can directly encode new DNA sequences",
  "The genome changes in different cell types while the proteome stays constant"
],
answer: 1
        },
        {
          question: "What does a small difference in DNA sequences between two species suggest about their evolutionary relationship?",
          options: [
            "They do not share a common ancestor",
            "They likely evolved under different environmental pressures",
            "They diverged from a common ancestor relatively recently",
            "One evolved directly from the other"
          ],
          answer: 2
        },
        {
          question: "Which best describes the difference between absolute and relative dating?",
          options: [
            "Absolute dating is faster",
            "Relative dating uses isotopes; absolute dating uses layers",
            "Absolute dating estimates actual age in years; relative dating compares order of events",
            "Relative dating only works for rocks younger than 10,000 years"
          ],
          answer: 2
        },
        {
          question: "What does a transitional fossil most directly demonstrate?",
          options: [
            "Extinction of older species",
            "Sudden appearance of new traits",
            "Intermediate traits between ancestral and derived species",
            "Variation within a single population"
          ],
          answer: 2
        }
      ]
    };

    // Initialize the game when page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>